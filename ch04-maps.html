<section data-type="chapter" id="chapter03">
<h1>Maps</h1>

<p>
In this chapter, you will work with maps (not to be confused with the 
<code>map</code> function, though you can use <code>map</code> on a map). Also, 
the études are designed to run on the server side with <a 
href="https://nodejs.org/">Node.js</a>, so you may want to see how to set that 
up in <a href="#appendix_server_cljs" data-type="xref">#appendix_server_cljs</a>.
</p>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <section data-type="sect1" id="ETUDE04-01">
  <h1>Étude 4-1: Condiments</h1>
  <p>
  If you spend some time going through open datasets such as those form <a href="http://www.data.gov/">data.gov</a>, you will find some fairly, shall we say, esoteric data. Among them is <a href="http://catalog.data.gov/dataset/mypyramid-food-raw-data-f9ed6">MyPyramid Food Raw Data</a> from the Food and Nutrition Service of the United States Department of Agriculture.
  </p>
  
  <p>
  One of the files is <em>Foods_Needing_Condiments_Table.xml</em>, which gives a list of foods and condiments that go with them. Here is what part of the file looks like, indented and edited to eliminate unnecessary elements, and placed in a file named <em>test.xml</em>.
  </p>
  
<pre>&lt;Foods_Needing_Condiments_Table&gt;
  &lt;Foods_Needing_Condiments_Row&gt;
    &lt;Survey_Food_Code&gt;51208000&lt;/Survey_Food_Code&gt;
    &lt;display_name&gt;100% Whole Wheat Bagel&lt;/display_name&gt;
    &lt;cond_1_name&gt;Butter&lt;/cond_1_name&gt;
    &lt;cond_2_name&gt;Tub margarine&lt;/cond_2_name&gt;
    &lt;cond_3_name&gt;Reduced calorie spread (margarine type)&lt;/cond_3_name&gt;
    &lt;cond_4_name&gt;Cream cheese (regular)&lt;/cond_4_name&gt;
    &lt;cond_5_name&gt;Low fat cream cheese&lt;/cond_5_name&gt;
  &lt;/Foods_Needing_Condiments_Row&gt;
  &lt;Foods_Needing_Condiments_Row&gt;
    &lt;Survey_Food_Code&gt;58100100&lt;/Survey_Food_Code&gt;
    &lt;display_name&gt;"Beef burrito (no beans):"&lt;/display_name&gt;
    &lt;cond_1_name&gt;Sour cream&lt;/cond_1_name&gt;
    &lt;cond_2_name&gt;Guacamole&lt;/cond_2_name&gt;
    &lt;cond_3_name&gt;Salsa&lt;/cond_3_name&gt;
  &lt;/Foods_Needing_Condiments_Row&gt;
  &lt;Foods_Needing_Condiments_Row&gt;
    &lt;Survey_Food_Code&gt;58104740&lt;/Survey_Food_Code&gt;
    &lt;display_name&gt;Chicken &amp; cheese quesadilla:&lt;/display_name&gt;
    &lt;cond_1_name&gt;Sour cream&lt;/cond_1_name&gt;
    &lt;cond_2_name&gt;Guacamole&lt;/cond_2_name&gt;
    &lt;cond_3_name&gt;Salsa&lt;/cond_3_name&gt;
  &lt;/Foods_Needing_Condiments_Row&gt;
&lt;/Foods_Needing_Condiments_Table&gt;</pre>

  <p>
  Your task, in this étude, is to take this JavaScript object build a ClojureScript map whose keys are the condiments and whose values are vectors of foods that go with those condiments. Thus, for the sample file, running the program from the command line the output would be this map (formatted and quotemarked for ease of reading):
  </p>
  
  <pre>[etudes@localhost nodetest]$ node condiments.js test.xml
{"Butter" ["100% Whole Wheat Bagel"],
"Tub margarine" ["100% Whole Wheat Bagel"],
"Reduced calorie spread (margarine type)" ["100% Whole Wheat Bagel"],
"Cream cheese (regular)" ["100% Whole Wheat Bagel"],
"Low fat cream cheese" ["100% Whole Wheat Bagel"],
"Sour cream" ["Beef burrito (no beans):" "Chicken &amp; cheese quesadilla:"],
"Guacamole" ["Beef burrito (no beans):" "Chicken &amp; cheese quesadilla:"],
"Salsa" ["Beef burrito (no beans):" "Chicken &amp; cheese quesadilla:"]}</pre>

    <section data-type="sect2" id="parse-xml">
    <h2>Parsing XML</h2>
    <p>
    How do you parse XML using Node.js? Install the <code>node-xml-lite</code> module:
    </p>
  
    <pre>[etudes@localhost ~]$ <strong>npm install node-xml-lite</strong>
npm http GET https://registry.npmjs.org/node-xml-lite
npm http 304 https://registry.npmjs.org/node-xml-lite
npm http GET https://registry.npmjs.org/iconv-lite
npm http 304 https://registry.npmjs.org/iconv-lite
node-xml-lite@0.0.3 node_modules/node-xml-lite
└── iconv-lite@0.4.8</pre>

    <p>
    Bring the XML parsing module into your <em>core.cljs</em> file:
    </p>
    
    <pre>(def xml (js/require "node-xml-lite"))</pre>
    
    <p>
    The following code will parse an XML file and return a JavaScript object:
    </p>
    
    <pre>(.parseFileSync xml "test.xml")</pre>
    
    <p>
    And here is the JavaScript object that it produces:
    </p>
    
  <pre>
  {:name "Foods_Needing_Condiments_Table", :childs [
    {:name "Foods_Needing_Condiments_Row", :childs [
      {:name "Survey_Food_Code", :childs ["51208000"]}
      {:name "display_name", :childs ["100% Whole Wheat Bagel"]}
      {:name "cond_1_name", :childs ["Butter"]}
      {:name "cond_2_name", :childs ["Tub margarine"]}
      {:name "cond_3_name", :childs ["Reduced calorie spread (margarine type)"]}
      {:name "cond_4_name", :childs ["Cream cheese (regular)"]}
      {:name "cond_5_name", :childs ["Low fat cream cheese"]}
    ]}
    {:name "Foods_Needing_Condiments_Row", :childs [
      {:name "Survey_Food_Code", :childs ["58100100"]}
      {:name "display_name", :childs ["Beef burrito (no beans):"]}
      {:name "cond_1_name", :childs ["Sour cream"]}
      {:name "cond_2_name", :childs ["Guacamole"]}
      {:name "cond_3_name", :childs ["Salsa"]}
    ]}
    {:name "Foods_Needing_Condiments_Row", :childs [
      {:name "Survey_Food_Code", :childs ["58104740"]}
      {:name "display_name", :childs ["Chicken &amp; cheese quesadilla:"]}
      {:name "cond_1_name", :childs ["Sour cream"]}
      {:name "cond_2_name", :childs ["Guacamole"]}
      {:name "cond_3_name", :childs ["Salsa"]}
    ]}
  ]}</pre>
    </section>
  
    <section data-type="sect2" id="command-line-options">
    <h2>Command Line Arguments</h2>
    <p>
    While you can hard-code the XML file name into your program, it makes the program less flexible. It would be much nicer if (as in the description of the étude) you could specify the file name to process on the command line.
    </p>
    <p>
    To get command line arguments, use the <code>arg</code> property of the global <code>js/process</code> variable. Element 0 is <code>"node"</code>, element 1 is the name of the JavaScript file, and element 2 is where your command line arguments begin. Thus, you can get the file name with:
    </p>
    
    <pre>(nth (.-argv js/process) 2)</pre>
    </section>
    
    <section data-type="sect2" id="mutual-recursion">
    <h2>Mutually Recursive Functions</h2>
  
    <p>
    While writing my solution, I had two separate functions: <code>process-children</code>, which iterated through all the <code>childs</code>. calling function <code>process-child</code> for each of them. However, a child element could itself have children, so <code>process-child</code> had to be able to call <code>process-children</code>. The term for this sort of situtation is that you have <em>mutually recursive functions</em>. Here’s the problem: ClojureScript requires you to define a function before you can use it, so you would think that you can’t have mutually recursive functions. Luckily, the inventor of Clojure foresaw this sort of situation and created the <code>declare</code> form which lets you declare a symbol that you will define later.  Thus, I was able to write code like this:
    </p>
  
    <pre>(declare process-child)
  
(defn process-children [...]
   (process-child ...))

(defn process-child [...]
   (process-children ...))</pre>
    
    <p>
    Just because I used mutually recursive functions to solve the problem doesn’t mean you have to. If you can find a way to do it with a single recursive function, go for it. I was following the philosophy of “the first way you think of doing it that works is the right way.”
    </p>
    </section>
    
  <p>
  There’s a lot of explanation in this étude, and you are probably thinking this is going to be a huge program. It sure seemed that way to me while I was writing it, but it turned that was mostly because I was doing lots of tests in the REPL and looking things up in documentation. When I looked at the resulting program, it was only 45 lines. Here it is: <a href="#SOLUTION04-ET01" 
data-type="xref">#SOLUTION04-ET01</a>

  </p>
  </section>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <section data-type="sect1" id="ETUDE04-02">
  <h1>Étude 4-2: Condiment Server</h1>
  <p>
  Now that you have the map from the previous étude, what can you do with it? Well, how many times have you been staring at that jar of mustard and asking yourself “What food would go well with this?” This étude will cure that indecision once and for all. You will write a server using <a href="http://expressjs.com/">Express</a>, which, as the web site says, is a “minimalist web framework for Node.js.” <a href="http://www.mase.io/code/clojure/node/2015/01/25/clojurescript-and-node-part-2-express/">This article about using ClojureScript and Express</a> was very helpful when I was first learning about the subject; I strongly suggest you read it.
  </p>
  
  <p>
  Let’s set up a simple server that you can use as a basis for this étude. The server presents a form with an input field for the user's name. When the user clicks the submit button,  the data is submitted back to the server and it echoes back the form and a message: “Pleased to meet you, <em>username</em>.”
   </p>
  
    <section id="setup-express" data-type="sect2">
    <h2>Setting up Express</h2>
    <p>You will need to do the following:</p>
    
    <ul>
    <li>Add <code>[express "4.11.1"]</code> to the <code>:node-dependencies</code> in your
    <em>project.clj</em> file.</li>
    <li>Add <code>(def express (nodejs/require "express"))</code> in your <em>core.cljs</em> file</li>
    <li>Make your <code>main</code> function look like this:
    
<pre>(defn -main []
  (let [app (express)]
    (.get app "/" generate-page!)
    (.listen app 3000
             (fn []
               (println "Server started on port 3000")))))</pre>
               
      <p>
      This starts a server on port 3000, and when it receives a <code>get</code> request, calls the <code>generate-page!</code> function. (You can also set up the server to accept <code>post</code> requests and route them to other URLS than the server root, but that is beyond the scope of this book.)
      </p>
      </li>
      </ul>
    </section>
    
    <section data-type="sect2" id="dynamic-html">
    <h2>Generating HTML from ClojureScript</h2>
    <p>
    To generate the HTML dynamically, you will use the <code>html</code> function of the <a href="">hiccups</a> library. The function takes as its argument a vector that has a keyword as an element name, an optional map of attributes and values, and element content.  Here are some examples:
      </p>
      
      <table>
        <thead>
          <tr><th>HTML</th><th>Hiccup</th></tr>
        </thead>
        <tbody>
        <tr>
          <td>&lt;h1&gt;Heading&lt;/h1&gt;</td>
          <td>(html [:h1 "Heading"])</td>
        </tr>
        <tr>
          <td>&lt;p id="intro"&gt;test&lt;/p&gt;</td>
          <td>(html [:p {:id "intro"} test])</td>
        </tr>
        <tr>
          <td>&lt;p&gt;Click to &lt;a href="page2.html"&gt;go to page two&lt;/a&gt;.&lt;/p&gt;</td>
          <td>(html [:p "Click to " [:a {:href "page2.html"} "go to page two"] "."])</td>
        </tr>
        </tbody>
      </table>
      
      <p>
      You add <code>[hiccups "0.3.0"]</code> to your <em>project.clj</em> dependencies and modify your <em>core.cljs</em> file to require hiccups:
      </p>
      
      <pre>(ns servertest.core
  (:require-macros [hiccups.core :as hiccups])
  (:require [cljs.nodejs :as nodejs]
            [hiccups.runtime :as hiccupsrt]))</pre>
            
      <p>
      You are now ready to write the <code>generate-page!</code> function, which has two parameters: the HTTP request that the server received, and the HTTP response that you will send back to the client.  The property <code>(.-query request)</code> is a JavaScript object with the form names as its properties.  Thus, if you have a form entry like this:
      </p>
      
      <pre>&lt;input type="text" name="userName"/&gt;</pre>
      
      <p>
      You would access the value via <code>(.-userName (.-query request))</code>.
      </p>
      
      <p>
      The <code>generate-page</code> function creates the HTML page as a string to send back to the client; you send it back by calling <code>(.send response <em>html-string</em>)</code>. The HTML page will contain a form whose <code>action</code> URL is the server root (<code>/</code>). The form will have an input area for the user name and a submit button. This will be followed by a paragraph that has the text “Pleased to meet you, <em>user name</em>.” (or an empty paragraph if there's no user name). You can either figure out this code on your own or <a href="#SOLUTION04-ET02A">see a suggested solution</a>. I’m giving you the code here because the purpose of this étude is to process the condiment map in the web page context rather than setting up the web page in the first place. (Of course, I strongly encourage you to figure it out on your own; you will learn a lot&#x2014;I certainly did!)
      </p>
      </section>
      
      <section data-type="sect2">
      <h2>Putting the Étude Together</h2>
      <p>
      Your program will use the previous étude’s code to build the map of condiments and compatible foods from the XML file. To make the program easier to read, I put the code for creating the map into a separate file with its own namespace. Then use the same framework that was developed in <a href="#dynamic-html" data-type="xref">#dynamic-html</a>, with the generated page containing:
      </p>
      
      <ul>
      <li>A form with a <code>&lt;select&gt;</code> menu that gives the condiment names (the keys of the map). You may want to add an entry with the text “Choose a condiment” at the beginning of the menu to indicate “no choice yet.” When you create the menu, remember to select the <code>selected="selected"</code> attribute for the current menu choice.</li>
      <li>A submit button for the form</li>
      <li>An unordered list that gives the matching foods for that condiment (the value from the map), or an empty list if no condiment has been chosen.</li>
      </ul>
      
      <p>
      Your code should alphabetize the condiment names and compatible foods. Some of the foods begin with capital letters; others with lower case. You will want to do a case-insensitive form. (Hint: use the form of <code>sort</code> that takes a comparison function.) 
      </p>
      
      <p>
      See a suggested solution: <a href="#SOLUTION04-ET02B" data-type="xref">#SOLUTION04-ET02B</a>
      </p>
      </section>
    </section>
</section>
